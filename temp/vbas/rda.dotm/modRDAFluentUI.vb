Attribute VB_Name = "modRDAFluentUI"
'===================================================================================================================================
' Module:       modRDAFluentUI
' Purpose:      Displays controls on the RDA Tab stub appropriate to the Assessment Report being edited or viewed.
'
' Note 1:       If the Assessment Report is not writable the DropDown and Buttons Groups will not be displayed.
' Note 2:       If the current document is not an Assessment Report no Groups will be displayed.
'
'               This allows the user to add and remove permitted sections of the document.
'               Currently the Tab layout consists of four groups of controls:
'               1.  Actions
'                   Contains the buttons for submitting or cancelling an Assessment Report.
'               2.  Report Views
'                   Contains the Refresh and Watermark buttons.
'               3.  Standards
'                   Contains the DropDown control that selects the Standard whose Finding can be added or deleted.
'               4.  ToggleButtons (Standard Sections)
'                   Contains the ToggleButton controls (laid out in Box controls) that allow a user to user to add or delete
'                   Findings for the selected Standard.
'
' Note 3:       The code in this module responds to the callbacks generated by the controls on the RDA Tab.
'
' Note 4:       The code in this module is comprised of three distinct functional groups:
'               1. Code to setup and respond (callback procedure) to the Fluent UI
'               2. Code to modify the g_xmlDocument xml.
'               3. Code to modify the Word Assessment Report document.
'
' Note 5:       ToggleButton control layout:
'
'               The toggleButton controls are laid out in 3 rows of 10 columns:
'
'               --------  --------  --------  --------  --------  --------  --------  --------  --------  --------
'               |   1  |  |   2  |  |   3  |  |   4  |  |   5  |  |   6  |  |   7  |  |   8  |  |   9  |  |  10  |
'               --------  --------  --------  --------  --------  --------  --------  --------  --------  --------
'               --------  --------  --------  --------  --------  --------  --------  --------  --------  --------
'               |  11  |  |  12  |  |  13  |  |  14  |  |  15  |  |  16  |  |  17  |  |  18  |  |  19  |  |  20  |
'               --------  --------  --------  --------  --------  --------  --------  --------  --------  --------
'               --------  --------  --------  --------  --------  --------  --------  --------  --------  --------
'               |  21  |  |  22  |  |  23  |  |  24  |  |  25  |  |  26  |  |  27  |  |  28  |  |  29  |  |  30  |
'               --------  --------  --------  --------  --------  --------  --------  --------  --------  --------
'
'               They are used in columns rather than sequentially, here is how they are used based on the number of toggleButtons
'               required.
'
'               Required    Layout used
'               --------    --------------------------------
'                1 -  3     Row  1,   Columns 1-3
'                4 -  6     Rows 1-2, Columns 1-3
'                7 -  9     Rows 1-3, Columns 1-3
'               10 - 12     Rows 1-3, Columns 1-4
'               13 - 15     Rows 1-3, Columns 1-5
'               16 - 18     Rows 1-3, Columns 1-6
'               19 - 21     Rows 1-3, Columns 1-7
'               22 - 24     Rows 1-3, Columns 1-8
'               25 - 27     Rows 1-3, Columns 1-9
'               28 - 30     Rows 1-3, Columns 1-10
'
' Example:      If 12 buttons are required, buttons:  1,  2,  3,  4,
'                                                    11, 12, 13, 14
'                                                    21, 22, 23, 24  will be used.
'
'               If 19 buttons are required, buttons:  1,  2,  3,  4,  5,  6,  7,
'                                                    11, 12, 13, 14, 15, 16, 17,
'                                                    21, 22, 23, 24, 25          will be used.
'
'
' Author:       Peter Hewett - Inner Word Limited (innerword@xnet.co.nz)
' Copyright:    Ministry of Social Development (MSD) ©2016 All rights reserved.
' Contact       Inner Word Limited
' details:      134 Kahu Road
'               Paremata
'               Porirua City
'               5024
'               T: +64 4 233 2124
'               M: +64 21 213 5063
'               E: innerword@xnet.co.nz
'
' History:      30/10/15    1.  Created.
'===================================================================================================================================
Option Explicit

' Built in Word Control Id's
Private Const mc_WCTabHome                      As String = "TabHome"

' Fluent UI Control Id's
Private Const mc_cidTabRDA                      As String = "msdTRDA"
Private Const mc_cidGroupActions                As String = "msdGActions"
Private Const mc_cidGroupReportViews            As String = "msdGReportViews"
Private Const mc_cidGroupDropDown               As String = "msdGDropDown"
Private Const mc_cidGroupButtons                As String = "msdGButtons"
Private Const mc_cidButtonSubmit                As String = "msdBSubmit"
Private Const mc_cidButtonCancel                As String = "msdBCancel"
Private Const mc_cidButtonRefresh               As String = "msdBRefresh"
Private Const mc_cidDropDown                    As String = "msdDD"
Private Const mc_cidToggleButtonWatermark       As String = "msdTBWatermark"
Private Const mc_cidBox1                        As String = "msdBx1"              ' Used to group ToggleButton controls  1-10
Private Const mc_cidBox2                        As String = "msdBx2"              ' Used to group ToggleButton controls 11-20
Private Const mc_cidBox3                        As String = "msdBx3"              ' Used to group ToggleButton controls 21-30
Private Const mc_cidToggleButtonBaseName        As String = "msdTB"               ' Base name for all ToggleButton controls

Private Const mc_toggleButtonCount              As Long = 30                      ' 10 columns, 3 rows

Private Const mc_successfulSubmitConfirmation   As String = "The report was submitted successfully."


Private m_ribbon                 As Office.IRibbonUI        ' Reference to the Fluent UI Ribbon object
Private m_insertIndex            As Long
Private m_primaryItemNames()     As String
Private m_selectedDropDownValue  As String
Private m_stateInfo()            As Boolean                 ' Store the Section toggleButton controls (pressed) state
Private m_tbMap()                As Long                    ' Maps a index number to an allocated toggleButton control
Private m_tbReverseMap()         As Long                    ' Return the index number for a given toggleButton control number

'=======================================================================================================================
' Procedure:    FUI_UILoaded
' Purpose:      The load ribbon (customUI.onLoad) callback procedure.
' Notes:        This is where the inital reference to the ribbon ui object is obtained.
'
' On Entry:     ribbon              Contains a reference to the Fluent UI Ribbon object.
'=======================================================================================================================
Public Sub FUI_UILoaded(ByVal ribbon As IRibbonUI)
    Const c_proc As String = "modRDAFluentUI.FUI_UILoaded"

    Debug.Print "RDA." & c_proc & ", ribbon Is Nothing: " & (ribbon Is Nothing)

    ' It is essential to store a references to the ribbon or we can't invalidate controls
    Set m_ribbon = ribbon

    EventLog "m_ribbon Is Nothing = " & (m_ribbon Is Nothing), c_proc

    If IsAssessmentReport Then
        RDA_RibbonReset
    Else
        RDA_InvalidateGroupControls
    End If
End Sub ' FUI_UILoaded

Public Sub FUI_TabRDA_getVisible(ByVal control As IRibbonControl, _
                                 ByRef tabVisible As Variant)
    Const c_proc As String = "modRDAFluentUI.FUI_TabRDA_getVisible"

    ' The RDA Tab control is only visible if the current document is a Manifest 2 or 3 assessment report
    If IsAssessmentReport Then
        tabVisible = (g_rootData.ManifestVersion <= 3)
    End If
End Sub ' FUI_TabRDA_getVisible

'=======================================================================================================================
' Procedure:    FUI_G_getVisible
' Purpose:      The Group getVisible callback procedure.
'               This procedure determines whether the control should be visible or not.
' Notes:        This callback is used by ALL Group controls.
'
' On Entry:     control             The control this callback is for.
'               groupVisible        Ignored.
' On Exit:      groupVisible        True if this control should be displayed.
'=======================================================================================================================
Public Sub FUI_G_getVisible(ByVal control As IRibbonControl, _
                            ByRef groupVisible As Variant)
    Const c_proc As String = "modRDAFluentUI.FUI_G_getVisible"

    ' The Group controls are only visible if the active document is an Assessment Report
    If IsAssessmentReport Then
        If control.Id = mc_cidGroupActions Then
            groupVisible = Not g_hasBeenSubmitted
        ElseIf control.Id = mc_cidGroupReportViews Then
            If Not g_rootData Is Nothing Then
                groupVisible = (g_rootData.ManifestVersion = 3)
            End If
        Else
            If Not g_rootData Is Nothing Then
                groupVisible = g_rootData.IsWritable
            End If
        End If
    End If
End Sub ' FUI_G_getVisible

'=======================================================================================================================
' Procedure:    FUI_BCancel_getLabel
' Purpose:      The Button getLabel callback procedure.
' Purpose:      This procedure returns the text displayed by the passed in Button control.
' Notes:        This button is labeled as "Cancel' or 'Close' depending on whether the Assessment Report can be updated.
'               If the Assessment Report can be updated then 'Cancel' is displayed.
'               If the Assessment Report can not be updated then 'Close' is displayed.
'
' On Entry:     control             The control this callback is for.
'               labelText           Ignored.
' On Exit:      labelText           The text displayed by the Button control.
'=======================================================================================================================
Public Sub FUI_BCancel_getLabel(ByVal control As IRibbonControl, _
                                ByRef labelText As Variant)
    Const c_proc As String = "modRDAFluentUI.FUI_BCancel_getLabel"

    ' For conformity with the way InfoPath did its thing we change the label caption depending on the View
    If IsAssessmentReport Then
        If g_rootData.IsWritable Then
            labelText = "Cancel"
        Else
            labelText = "Close"
        End If
    End If
End Sub ' FUI_BCancel_getLabel

'=======================================================================================================================
' Procedure:    FUI_BCancel_onAction
' Purpose:      The Cancel/Close Button onAction callback procedure.
' Note 1:       Cancels any/all changes to the Assessment Report.
' Note 2:       If the button is labeled as "Cancel' then the Assessment Report xml is reloaded wiping out any changes
'               the user may have made to the data and the reloaded xml is submitted to the Remedy/RDA webservice.
' Note 3:       If the button is labeled as "Close' then we do not submit the xml to the Remedy/RDA webservice.
'
' On Entry:     control             The control this callback is for.
'=======================================================================================================================
Public Sub FUI_BCancel_onAction(ByVal control As IRibbonControl)
    Const c_proc         As String = "modRDAFluentUI.FUI_BCancel_onAction"
    Const c_msgboxPrompt As String = "Are you sure you want to discard any/all changes?"
    Const c_msgboxTitle  As String = "Cancel Assessment Report"

    On Error GoTo Do_Error

    If IsAssessmentReport Then
        If g_rootData.IsWritable Then

            ' This is for when the button is labeled 'Cancel'
            If MsgBox(c_msgboxPrompt, vbYesNo Or vbDefaultButton2 Or vbQuestion, c_msgboxTitle) = vbYes Then

                ' Close the Assessment Report document
                CloseAssessmentReportDocument

                ' We need to discard any changes made to the Assessment Report xml.
                ' The easiest way to do this is to reload the original Assessment Report xml.
                If LoadAssessmentReport(g_configuration.InputXMLFileFullPath) Then

                    ' Set the 'Assessment' nodes 'dataChanged' attribute to "No"
                    SetDataChangedAttribute False

                    ' Now submit the xml (in g_xmlDocument) to the Remedy/RDA webservice
                    SubmitXMLToWebService True
                End If
            Else
                Exit Sub
            End If
        Else

            ' Close the Assessment Report document
            CloseAssessmentReportDocument

            ' At this point the RDA Tab is no longer usable for this Assessment Report so disable it
            ResetAlmostEverything
        End If
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' FUI_BCancel_onAction

'=======================================================================================================================
' Procedure:    FUI_BRefresh_getVisible
' Purpose:      The Refresh Button onAction callback procedure.
' Notes:        The Refresh button is only visible when the Assessment Report is updateable.
'
' On Entry:     control             The control this callback is for.
'=======================================================================================================================
Public Sub FUI_BRefresh_getVisible(ByVal control As IRibbonControl, _
                                   ByRef buttonVisible As Variant)
    If IsAssessmentReport Then
        buttonVisible = g_rootData.IsWritable
    End If
End Sub ' FUI_BRefresh_getVisible

'=======================================================================================================================
' Procedure:    FUI_BRefresh_onAction
' Purpose:      The Refresh Button onAction callback procedure.
' Notes:        Updates all Ref Fields (called roll-up by MSD as it updates data in the executive summary).
'
' On Entry:     control             The control this callback is for.
'=======================================================================================================================
Public Sub FUI_BRefresh_onAction(ByVal control As IRibbonControl)
    Const c_proc As String = "modRDAFluentUI.FUI_BRefresh_onAction"

    On Error GoTo Do_Error

    ' Refresh everything that needs regenerating in the current Assessment Report
    RDAFullRefresh

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' FUI_BRefresh_onAction

'=======================================================================================================================
' Procedure:    FUI_BSubmit_getVisible
' Purpose:      The Submit Button controls getVisible callback procedure.
'
' On Entry:     control             The control this callback is for.
'               buttonVisible       Ignored.
' On Exit:      buttonVisible       True if the button is visible
'=======================================================================================================================
Public Sub FUI_BSubmit_getVisible(ByVal control As IRibbonControl, _
                                  ByRef buttonVisible As Variant)
    If IsAssessmentReport Then
        If Not g_rootData Is Nothing Then
            buttonVisible = g_rootData.IsWritable
        End If
    End If
End Sub ' FUI_BSubmit_getVisible

'=======================================================================================================================
' Procedure:    FUI_BSubmit_onAction
' Purpose:      The Submit Button onAction callback procedure.
' Notes:        .
'
' On Entry:     control             The control this callback is for.
'=======================================================================================================================
Public Sub FUI_BSubmit_onAction(ByVal control As IRibbonControl)
    Const c_proc As String = "modRDAFluentUI.FUI_BSubmit_onAction"

    Dim arFile      As Scripting.File
    Dim arFullName  As String
    Dim theFSO      As Scripting.FileSystemObject

    On Error GoTo Do_Error

    ' This really should not be necessary
    If IsAssessmentReport Then

        ' Check that the document does not contain prohibited content
        If PreSubmitVetting Then

            ' Set the 'Assessment' nodes 'dataChanged' attribute to "Yes"
            SetDataChangedAttribute True

            ' Validate all editable date fields (and update the underlying Assessment Report xml)
            If ValidateAllEditableDates Then

                ' Now take all editable RichText and Multiline input areas and indirectly
                ' use that data to update the underlying Assessment Report xml
                UpdateAssessmentReportXMLUsingRichText

                ' Save and close the Assessment Report document, this is to circumvent the orphan document problem caused by
                ' submitting the Assessment Report xml and then closing the Assessment Report document, which leaves a window
                ' with no document that is not included in Words global Documents object Count!
                SaveAndCloseAssessmentReportDocument

                ' Get the name pf the saved Assessment Report document file
                arFullName = g_configuration.AssessmentReportFileFullName

                ' Now return the xml (in g_xmlDocument) to the Remedy/RDA webservice
                If SubmitXMLToWebService Then
                    MsgBox mc_successfulSubmitConfirmation, vbOKOnly And vbExclamation, rdaTitle

                    ' Now delete the saved Assessment Report document file
                    Set theFSO = New Scripting.FileSystemObject
                    Set arFile = theFSO.GetFile(arFullName)
                    arFile.Delete True
                    Set theFSO = Nothing
                Else

                    ' Reopen the Assessment Report document so that the user can see that they have not lost their work.
                    ' Do not assign the the document to g_assessmentReport as this will prevent the user from creating
                    ' a new Assessment Report.
                    Documents.Open arFullName
                End If
            End If
        End If
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' FUI_BSubmit_onAction

'=======================================================================================================================
' Procedure:    FUI_DD_getItemCount
' Purpose:      The DropDown controls getItemCount callback procedure.
'               We return the number of items in the DropDown list. As a consequence of this, FUI_DD_getItemLabel will
'               be called itemCount number of times.
'
' On Entry:     control             The control this callback is for.
'               itemCount           Ignored.
' On Exit:      itemCount           The number of items we want to add to the DropDown list.
'=======================================================================================================================
Public Sub FUI_DD_getItemCount(ByVal control As IRibbonControl, _
                               ByRef itemCount As Variant)
    Const c_proc As String = "modRDAFluentUI.FUI_DD_getItemCount"

    EventLog c_proc
    If Not Not m_primaryItemNames Then
        itemCount = UBound(m_primaryItemNames)
        EventLog "Item count: " & itemCount, c_proc
    End If
End Sub ' FUI_DD_getItemCount

'=======================================================================================================================
' Procedure:    FUI_DD_getItemLabel
' Purpose:      The DropDown controls getItemLabel callback procedure.
'
' On Entry:     control             The control this callback is for.
'               index               The index value of the item that we need to return a label for.
'               labelText           Ignored
' On Exit:      labelText           The label text to be displayed by the indexed item of the DropDown control.
'=======================================================================================================================
Public Sub FUI_DD_getItemLabel(ByVal control As IRibbonControl, _
                               ByVal index As Integer, _
                               ByRef labelText As Variant)
    Const c_proc As String = "modRDAFluentUI.FUI_DD_getItemLabel"

    EventLog c_proc
    If Not Not m_primaryItemNames Then
        labelText = m_primaryItemNames(index + 1)
    End If
End Sub ' FUI_DD_getItemLabel

'=======================================================================================================================
' Procedure:    FUI_DD_onAction
' Purpose:      The DropDown controls onAction callback procedure.
'
' On Entry:     control             The control this callback is for.
'               id                  The id (name) of the control this callback is for.
'               index               The index of the item that was pressed.
' On Exit:      m_tbMap             Array Setup.
'               m_tbReverseMap      Array Setup
'               m_stateInfo         Array Setup.
'=======================================================================================================================
Public Sub FUI_DD_onAction(ByVal control As IRibbonControl, _
                           ByVal Id As String, _
                           ByVal index As Integer)
    Const c_proc As String = "modRDAFluentUI.FUI_DD_onAction"

    Dim indexNumber   As Long
    Dim itemCount     As Long
    Dim itemIndex     As Long
    Dim theQuery      As String
    Dim theNodes      As MSXML2.IXMLDOMNodeList
    Dim theText       As String

    On Error GoTo Do_Error

    Debug.Print "id = " & Id & ", index = " & index

    ' Query retrieves nodes used to build the DropDown controls items
    theQuery = Replace$(g_instructions.UserInterface.QueryVisibleToggleButtons, mgrP1, m_primaryItemNames(index + 1))

    Debug.Print theQuery

    ' Run the query to retieve the nodes that will provide the data for the Primary dropDown control
    Set theNodes = g_xmlDocument.SelectNodes(theQuery)

    ' Set up the mapping of data to toggleButton control based on how many toggleButton controls are actually required
    itemCount = theNodes.Length
    If itemCount > 0 Then

        ' Genearate the button map so that we know what controls we are using and what controls should be invisible
        GenerateButtonMap itemCount

        If Not m_ribbon Is Nothing Then
            
            InvalidateToggleButtonControls

            ' Save the index value so that we can access it from other controls callback procedures
            m_selectedDropDownValue = m_primaryItemNames(index + 1)
            
            ' Shortcut for initialising the entire array to false
            ReDim m_stateInfo(1 To mc_toggleButtonCount)

            ' Query picks all nodes that require a tick
            theQuery = Replace$(g_instructions.UserInterface.QueryToggleButtonSiblings, mgrP1, m_selectedDropDownValue)
            Set theNodes = g_xmlDocument.SelectNodes(theQuery)

            ' Iterate all nodes that require a tick
            For itemIndex = 1 To theNodes.Length

                ' Use the nodes text value as the index to which item requires a tick image
                theText = theNodes(itemIndex - 1).Text

                ' This is an attempt to deal to null/nil values - which appear on the surface to be invalid?
                If LenB(theText) > 0 Then
                    indexNumber = CLng(theText)
                Else
                    indexNumber = itemIndex
                End If

                ' Save the state of all items for the selected DropDown item
                m_stateInfo(m_tbMap(indexNumber)) = True
            Next
        End If
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' FUI_DD_onAction

'=======================================================================================================================
' Procedure:    FUI_Secondary_getImage
' Purpose:      The toggleButton getImage callback procedure.
'               This procedure determines whether a tick or no image is displayed by each control.
' Notes:        This callback is used by ALL toggle button controls grouped on the third Tab.
'
' On Entry:     control             The control this callback is for.
'               imageMso            Ignored.
' On Exit:      imageMso            The image or Null to be display by this control.
'=======================================================================================================================
Public Sub FUI_Secondary_getImage(ByVal control As IRibbonControl, _
                                  ByRef imageMso As Variant)
    Const c_proc As String = "modRDAFluentUI.FUI_Secondary_getImage"

    Dim controlNumber As Long
    Dim display       As Boolean

    If Not Not m_stateInfo Then

        ' Get the sequential number from the control number
        controlNumber = ControlIndexFromControlName(control.Id)

        ' If this control is selected (pressed = True) then it should display the tick image
        display = m_stateInfo(controlNumber)
        SetupSectionImage imageMso, display
'''        Debug.Print "FUI_Secondary_getImage: " & control.Id
    End If
End Sub ' FUI_Secondary_getImage

'=======================================================================================================================
' Procedure:    FUI_Secondary_getLabel
' Purpose:      The toggleButton getLabel callback procedure.
' Purpose:      This procedure returns the text displayed by the passed in ToggleButton control.
' Notes:        This callback is used by ALL toggle button controls grouped on the fourth Tab.
'
' On Entry:     control             The control this callback is for.
'               labelText           Ignored.
' On Exit:      labelText           The text displayed by the toogleButton control.
'=======================================================================================================================
Public Sub FUI_Secondary_getLabel(ByVal control As IRibbonControl, _
                                  ByRef labelText As Variant)
    Const c_proc As String = "modRDAFluentUI.FUI_Secondary_getLabel"

    Dim controlNumber As Long
    Dim index         As Long

    If Not Not m_tbMap Then

        ' Get the sequential number from the control number
        controlNumber = ControlIndexFromControlName(control.Id)

        ' Now get the actual items number so that it can be displayed as part of the label
        index = m_tbReverseMap(controlNumber)

        ' Now create the label
        If index < 10 Then
            labelText = "Section   " & CStr(index)
        Else
            labelText = "Section " & CStr(index)
        End If
    End If
End Sub ' FUI_Secondary_getLabel

'=======================================================================================================================
' Procedure:    FUI_Secondary_getPressed
' Purpose:      The toggleButton getPressed callback procedure.
' Notes:        This callback is used by ALL toggle button controls grouped on the third Tab.
'
' On Entry:     control             The control this callback is for.
'               isPressed           Ignored.
' On Exit:      isPressed           True for pressed.
'=======================================================================================================================
Public Sub FUI_Secondary_getPressed(ByVal control As IRibbonControl, _
                                    ByRef isPressed As Variant)
    Const c_proc As String = "modRDAFluentUI.FUI_Secondary_getPressed"

    Dim controlNumber As Long

    ' This code sets the toggle buttons up to show as pressed (the control displays a gold background) when there is a
    ' corresponding xml and document section for the selected control. Likewise if the user selects a unselected
    ' control its background colour will turn gold, since we will add the necessary xml and document section.

    If Not Not m_stateInfo Then

        ' Get the sequential number from the control number
        controlNumber = ControlIndexFromControlName(control.Id)

        isPressed = m_stateInfo(controlNumber)
'''        Debug.Print "FUI_Secondary_getPressed (" & control.Id & "): " & isPressed
    End If
End Sub ' FUI_Secondary_getPressed

'=======================================================================================================================
' Procedure:    FUI_Secondary_getVisible
' Purpose:      The toggleButton getVisible callback procedure.
'               This procedure determines whether the control should be visible or not.
' Notes:        This callback is used by ALL toggle button controls grouped on the third Tab.
'
' On Entry:     control             The control this callback is for.
'               toggleButtonVisible Ignored.
' On Exit:      toggleButtonVisible True if this control should be displayed.
'=======================================================================================================================
Public Sub FUI_Secondary_getVisible(ByVal control As IRibbonControl, _
                                    ByRef toggleButtonVisible As Variant)
    Const c_proc As String = "modRDAFluentUI.FUI_Secondary_getVisible"

    Dim controlNumber As Long

    If Not Not m_tbMap Then
        
        controlNumber = ControlIndexFromControlName(control.Id)

        toggleButtonVisible = (m_tbReverseMap(controlNumber) <> 0)
    End If
End Sub ' FUI_Secondary_getVisible

'=======================================================================================================================
' Procedure:    FUI_Secondary_onAction
' Purpose:      The Secondary toggleButton onAction callback procedure.
'               This procedure does the actual work to respond to the button press.
' Notes:        This callback is used by ALL toggle button controls grouped on the third Tab.
'
' On Entry:     control             The control this callback is for.
'               pressed             True if the control is pressed.
'=======================================================================================================================
Public Sub FUI_Secondary_onAction(ByVal control As IRibbonControl, _
                                  ByVal pressed As Boolean)
    Const c_proc As String = "modRDAFluentUI.FUI_Secondary_onAction"

    Dim controlNumber As Long

    On Error GoTo Do_Error

    ' Make sure the ribbon is valid before trying to use it
    If Not m_ribbon Is Nothing Then

        ' See if the Bookmarks need to be rebuild.  They can get screwed up by the user cutting
        ' and pasting text exactly equal to the Range of the Bookmark being copied and pasted.
        If g_assessmentReport.bookmarks.Count < g_bookmarkCount Then
            RebuildBookmarksBeforeEdit
        End If

        ' Get the control number from the control name
        controlNumber = ControlIndexFromControlName(control.Id)

        ' Based on the pressed value we now need to either add something to
        ' the xml and document or delete something from the xml and document
        If (pressed) Then

            AddToXMLAndDocument controlNumber
        Else

            DeleteFromXMLAndDocument controlNumber
        End If

        ' Toggle the state value
        m_stateInfo(controlNumber) = Not m_stateInfo(controlNumber)

        ' We now need to invalidate this control so that the FUI_Secondary_getImage callback
        ' procedure is called so that the tick mark (image) can be toggled on and off
        m_ribbon.InvalidateControl control.Id

        ' Update the global Bookmark count since it will have changed
        g_bookmarkCount = g_assessmentReport.bookmarks.Count

        ' This is very slow but seemingly necessary because of the way certain Bookmarks get extended
        RebuildBookmarksBeforeEdit
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' FUI_Secondary_onAction

'=======================================================================================================================
' Procedure:    FUI_TBWatermark_getPressed
' Purpose:      The Watermark toggleButton getPressed callback procedure.
' Notes:        This callback is used by ALL toggle button controls grouped on the third Tab.
'
' On Entry:     control             The control this callback is for.
'               isPressed           Ignored.
' On Exit:      isPressed           True for pressed.
'=======================================================================================================================
Public Sub FUI_TBWatermark_getPressed(ByVal control As IRibbonControl, _
                                      ByRef isPressed As Variant)
    Const c_proc As String = "modRDAFluentUI.FUI_TBWatermark_getPressed"

    ' Set the ToggleButton pressed state based on whether the Assessment Report has a Watermark
    isPressed = HasWatermark
End Sub ' FUI_TBWatermark_getPressed

'=======================================================================================================================
' Procedure:    FUI_TBWatermark_getVisible
' Purpose:      The Watermark toggleButton getVisible callback procedure.
'
' On Entry:     control             The control this callback is for.
'               buttonVisible       Ignored.
' On Exit:      buttonVisible       True if the button is visible
'=======================================================================================================================
Public Sub FUI_TBWatermark_getVisible(ByVal control As IRibbonControl, _
                                      ByRef toggleButtonVisible As Variant)
    If Not g_rootData Is Nothing Then
        toggleButtonVisible = (g_rootData.ManifestVersion = 3)
    End If
End Sub ' FUI_TBWatermark_getVisible

'=======================================================================================================================
' Procedure:    FUI_TBWatermark_onAction
' Purpose:      The TWatermark toggleButton onAction callback procedure.
' Notes:        Adds or removes the Assessment Reports watermark.
'               The watermark in present by default, but the user will want to remove it before printing.
'
' On Entry:     control             The control this callback is for.
'               pressed             True if pressed.
'=======================================================================================================================
Public Sub FUI_TBWatermark_onAction(ByVal control As IRibbonControl, _
                                    ByVal pressed As Boolean)
    Const c_proc As String = "modRDAFluentUI.FUI_TBWatermark_onAction"

    If HasWatermark Then
        RemoveWatermark
    Else
        AddWatermark
    End If
End Sub ' FUI_TBWatermark_onAction

'=======================================================================================================================
' Procedure:    SetupSectionImage
' Purpose:      Assigns the image to be used by each of the Section controls.
'
' On Entry:     image               Ignored.
'               hasImage            True if the check icon image should be assigned.
' On Exit:      image               The image to be displayed by a Country control.
'=======================================================================================================================
Private Sub SetupSectionImage(ByRef image As Variant, _
                              ByVal hasImage As Boolean)
    Const c_proc As String = "modRDAFluentUI.SetupSectionImage"

    On Error GoTo Do_Error

    If hasImage Then

        ' This just puts a tick besides the selected menu item
        Set image = Application.CommandBars.GetImageMso("AcceptInvitation", 16, 16)
    Else

        ' This clears any tick besides the selected menu item
        Set image = Nothing
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' SetupSectionImage

'=======================================================================================================================
' Procedure:    ControlIndexFromControlName
' Purpose:      Returns the passed in controls index number which is derived from the controls name.
' Notes:        For this code to work it is expected that the last one or two characters of the control name are
'               numeric.
'
' On Entry:     controlName         The controls name.
' Returns:      The controls index number.
'=======================================================================================================================
Private Function ControlIndexFromControlName(ByVal controlName As String) As Long
    Dim rightOne As String
    Dim rightTwo As String

    ' Get the last character and the last two characters of the controls name
    rightOne = Right$(controlName, 1)
    rightTwo = Right$(controlName, 2)

    If IsNumeric(rightTwo) Then
        ControlIndexFromControlName = CLng(rightTwo)
    ElseIf IsNumeric(rightOne) Then
        ControlIndexFromControlName = CLng(rightOne)
    Else
        Err.Raise 666
    End If
End Function ' ControlIndexFromControlName

'=======================================================================================================================
' Procedure:    RDA_RibbonReset
' Purpose:      Performs a full reset of the RDA Tab.
' Notes:        We also reset the module level variables used by the RDA Tab for lookup and control state information.
'=======================================================================================================================
Public Sub RDA_RibbonReset()
    Const c_proc As String = "modRDAFluentUI.RDA_RibbonReset"

    On Error GoTo Do_Error

    EventLog "m_ribbon Is Nothing = " & (m_ribbon Is Nothing), c_proc

    ' Activate Words 'Home' Tab because if the RDA Tab is active it does not refresh.
    ' This way the user has to select the RDA Tab and that forces the refresh.
    If Not m_ribbon Is Nothing Then
        m_ribbon.ActivateTabMso mc_WCTabHome
    End If

    ' Erase all variables used by the previous Assment Report instance
    m_insertIndex = 0
    m_selectedDropDownValue = vbNullString
    Erase m_primaryItemNames()
    Erase m_stateInfo()
    Erase m_tbMap()
    Erase m_tbReverseMap()

    ' Setup the data consumed by the DropDown control
    SetupDropdownListData

    ' The FluentUI does not invaildate child controls when invalidating
    ' any of the container controls so we invalidate everything
    RDA_InvalidateGroupControls

    ' If the document is not an Assessment Report then all of the Group controls should
    ' be invisible, in which case we do not need to do anything with the child controls
    If IsAssessmentReport Then
        EventLog "Invalidating Action, DropDown and Toggle Button controls", c_proc
        InvalidateActionControls
        InvalidateReportViewsControls
        InvalidateDropDownControl
        InvalidateToggleButtonControls
    End If

    ' Set the global Bookmark count as Bookmarks can get deleted when the
    ' user cuts and pastes a Range exactly equal to the Bookmarks Range
    If Not g_assessmentReport Is Nothing Then
        g_bookmarkCount = g_assessmentReport.bookmarks.Count
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' RDA_RibbonReset

Public Sub ResetAlmostEverything()
    Const c_proc As String = "modRDAFluentUI.ResetAlmostEverything"

    On Error GoTo Do_Error

    ' Reset all global objects specific to an Assessment Report. We don't reset general global objects
    ' that require persistance: g_wordEvents, g_configuration, g_eventLog and g_hasBeenSubmitted
    Set g_htmlWordDocument = Nothing
    Set g_xmlDocument = Nothing
    Set g_xmlInstructionData = Nothing
    Set g_htmlTextDocument = Nothing

    g_bookmarkCount = 0
    Set g_addsWithRefresh = Nothing
    Set g_counters = Nothing
    Set g_editableBookmarks = Nothing
    Set g_instructions = Nothing
    Set g_richTextData = Nothing
    Set g_rootData = Nothing

    ' Now force the ribbon reset
    RDA_RibbonReset
Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' ResetAlmostEverything

Public Sub InvalidateActionControls()
    If Not m_ribbon Is Nothing Then
        m_ribbon.InvalidateControl mc_cidButtonSubmit
        m_ribbon.InvalidateControl mc_cidButtonCancel
    End If
End Sub ' InvalidateActionControls

Public Sub InvalidateDropDownControl()
    Const c_proc As String = "modRDAFluentUI.InvalidateDropDownControl"

    If Not m_ribbon Is Nothing Then
    ' DEBUG:    EventLog "Invalidating DropDown control", c_proc
        m_ribbon.InvalidateControl mc_cidDropDown
    End If
End Sub ' RDA_InvalidateGroupControls

Public Sub RDA_InvalidateGroupControls()
    Const c_proc As String = "modRDAFluentUI.RDA_InvalidateGroupControls"

    On Error GoTo Do_Error

    ' DEBUG:    EventLog "m_ribbon Is Nothing = " & (m_ribbon Is Nothing), c_proc

    If Not m_ribbon Is Nothing Then
        With m_ribbon

            ' It is critical we invalidate the Tab so that its visibility is reassessed
            .InvalidateControl mc_cidTabRDA

            .InvalidateControl mc_cidGroupActions
            .InvalidateControl mc_cidGroupReportViews
            .InvalidateControl mc_cidGroupDropDown
            .InvalidateControl mc_cidGroupButtons
        End With
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' RDA_InvalidateGroupControls

Public Sub InvalidateReportViewsControls()
    If Not m_ribbon Is Nothing Then
        m_ribbon.InvalidateControl mc_cidButtonRefresh
        m_ribbon.InvalidateControl mc_cidToggleButtonWatermark
    End If
End Sub ' InvalidateActionControls

Public Sub InvalidateToggleButtonControls()
    Const c_proc As String = "modRDAFluentUI.InvalidateToggleButtonControls"

    Dim controlId     As String
    Dim controlNumber As Long

    On Error GoTo Do_Error

    If Not m_ribbon Is Nothing Then

        ' Invalidate all of the toggleButton controls so that they can reset their Visibility, etc.
        For controlNumber = 1 To mc_toggleButtonCount

            ' Generate the control id
            controlId = mc_cidToggleButtonBaseName & CStr(controlNumber)

            ' Invalidate the toggleButton control
            ' DEBUG:    EventLog "Invalidating ToggleButton control: " & controlId, c_proc
            m_ribbon.InvalidateControl controlId
        Next
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' InvalidateToggleButtonControls

'=======================================================================================================================
' Procedure:    SetupDropdownListData
' Purpose:      Sets up the data consumed by the DropDown control.
'
' On Exit:      m_primaryItemNames  The values to be used as the DropDown controls item labels.
'=======================================================================================================================
Private Sub SetupDropdownListData()
    Const c_proc As String = "modRDAFluentUI.SetupDropdownListData"

    Dim index    As Long
    Dim theQuery As String
    Dim theNode  As MSXML2.IXMLDOMNode
    Dim theNodes As MSXML2.IXMLDOMNodeList

    On Error GoTo Do_Error

    EventLog c_proc

    If Not g_instructions Is Nothing Then

        ' Get the query we need for creating the DropDown controls data
        If Not g_instructions.UserInterface Is Nothing Then
            theQuery = g_instructions.UserInterface.QueryBuildDropDown

            ' Run the query to retieve the nodes that will provide the data for the Primary dropDown control
            If LenB(theQuery) > 0 Then
                Set theNodes = g_xmlDocument.SelectNodes(theQuery)

                ' Make sure there actually is some data
                If theNodes.Length > 0 Then

                    ' Resize array to hold the exact number of data items returned by the query
                    ReDim m_primaryItemNames(1 To theNodes.Length)

                    ' Extract the values from the xml and store in module scope array
                    For Each theNode In theNodes
                        index = index + 1

                        ' Get the text value of the current node
                        m_primaryItemNames(index) = theNode.Text
                    Next
                End If
            End If
        End If
    End If

    ' Now that we have assembled the data, invalidate the control so that it rebuilds itself using said data
    If Not m_ribbon Is Nothing Then
        ' DEBUG:    Debug.Print "invalidating DropDown control"
        m_ribbon.InvalidateControl mc_cidDropDown
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' SetupDropdownListData

'=======================================================================================================================
' Procedure:    GenerateButtonMap
' Purpose:      Based on the passed in value of maxNo determines which toggleButton controls will be used.
'               The toggleButtons are laid out in 3 rows of 10 columns, but only the controls being used are visible.
' Notes:        The controls are used in column groups rather than sequentially. See this modules header for more info.
'
' On Entry:     maxNo               The number of toggleButton controls that will be used.
' On Exit:      m_tbMap             Update with generated control number mapping.
'=======================================================================================================================
Private Sub GenerateButtonMap(ByVal maxNo As Long)
    Const c_proc         As String = "modRDAFluentUI.GenerateButtonMap"
    Const c_numberOfRows As Long = 3
    Const c_stepInterval As Long = 10

    Dim baseNo    As Long
    Dim Counter   As Long
    Dim carryOver As Long
    Dim divisor   As Long
    Dim index     As Long
    Dim maxNoCopy As Long
    Dim remainder As Long

    On Error GoTo Do_Error

    EventLog c_proc

    ' Always redim these arrays as its a quick way of setting all elements to zero
    ReDim m_tbMap(1 To mc_toggleButtonCount)
    ReDim m_tbReverseMap(1 To mc_toggleButtonCount)

    ' Initialise baseNo used for row roll over
    baseNo = 1

    ' Calculate the divisor based on the total number of toogleButton controls that will be used.
    ' This causes the controls to be used in a non linear manor, which in turn makes the Tab Group look better.
    ' See the documentation in this modules header for a detailed explanation of what is going on here.
    maxNoCopy = maxNo
    divisor = 3
    Do While maxNoCopy > 9
        divisor = divisor + 1
        maxNoCopy = maxNoCopy - c_numberOfRows
    Loop

'''    Debug.Print "divisor = " & divisor

    ' Determine which toggleButton controls will actually be used
    For index = 1 To maxNo
        remainder = index Mod divisor

        ' If the remainder is zero the next control number (not this control number) will be one on the next row
        If remainder = 0 Then

            ' Set the control number that will be used next time
            Counter = Counter + 1
            baseNo = baseNo + c_stepInterval
            carryOver = baseNo
        Else
        
            ' If carryOver is non zero then this control start at the begining of the next row
            If carryOver > 0 Then
            
                ' Overwrite the counter value with the value of the first control in the next row
                Counter = carryOver

                ' carryOver now needs to be reset
                carryOver = 0
            Else

                ' Just increment the counter as usual
                Counter = Counter + 1
            End If
        End If

        ' Map the linear control number (index) to the actual toggleButton control number
        m_tbMap(index) = Counter

        ' Map the control number to its index number
        m_tbReverseMap(Counter) = index

'''        Debug.Print counter
    Next

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' GenerateButtonMap

Private Sub FUIActions(ByVal actionList As VBA.Collection)
    Const c_proc As String = "modRDAFluentUI.FUIActions"

    Dim errorText As String
    Dim theAction As Object

    On Error GoTo Do_Error

    If actionList Is Nothing Then
        Exit Sub
    End If

    ' Iterate all ActionSetup, ActionAdd and ActionInsert objects in the collection
    For Each theAction In actionList

        ' There are four types of objects in this collection so choose the method appropriate to the object
        Select Case TypeName(theAction)
        Case rdaTypeActionAdd
            FUIActionAdd theAction

        Case rdaTypeActionInsert
            BARActionInsert theAction

        Case rdaTypeActionLink
            ' Not required here (should never be necessary to use in the userinterface node block)

        Case rdaTypeActionRename
            BARActionRename theAction

        Case rdaTypeActionSetup
            FUIActionSetup theAction

        Case Else
            errorText = Replace$(mgrErrTextUnknownActionVerbType, mgrP1, TypeName(theAction))
            Err.Raise mgrErrNoUnknownActionVerbType, c_proc, errorText
        End Select
    Next

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' FUIActions

Private Sub FUIActionAdd(ByVal info As ActionAdd)
    Const c_proc As String = "modRDAFluentUI.FUIActionAdd"

    Dim bbName            As String
    Dim bbWhere           As rdaWhere
    Dim bookmarkExtend    As Boolean
    Dim bookmarkName      As String
    Dim bookmarkToDelete  As String
    Dim followingBookmark As String
    Dim index             As Long
    Dim theQuery          As String
    Dim subNode           As MSXML2.IXMLDOMNode

    On Error GoTo Do_Error

    ' Update any predicate placeholders in the xpath query with their appropriate indexed value.
    ' Since we have not started updating the counters for the current nesting depth yet this lags by depth-1
    theQuery = g_counters.UpdatePredicates(info.Test)

    ' Use the ActionAdd objects 'test' string as an xpath query to retrieve the matching node
    Set subNode = g_xmlDocument.SelectSingleNode(theQuery)

    ' There is only something to do if the xpath query actually returned a node
    If Not subNode Is Nothing Then

        ' Set the index value using the counter value that was manually set for the item we are inserting
        index = g_counters.Count(2)

        ' If this Section uses more than one Building Block, choose the Building Block
        ' based on this sections counter. This allows a different Building Block to be
        ' used the first time a Building Block is added to the document.
        If index = 1 Then
            bbName = info.BuildingBlock
            bbWhere = info.Where
            bookmarkName = info.Bookmark
            bookmarkExtend = info.ExtendBookmark
        Else
            bbName = info.BuildingBlockN
            bbWhere = info.WhereN
            bookmarkName = info.BookmarkN
            bookmarkExtend = info.ExtendBookmarkN
        End If

        ' Replace any numeric placeholders in the Bookmark names with their actual values
        followingBookmark = info.BookmarkN
        bookmarkName = InsertNumericParameters(bookmarkName, g_counters.Count(1), index - 1)
        followingBookmark = InsertNumericParameters(followingBookmark, g_counters.Count(1), index + 1)

        ' Insert the selected Building Block
        FUIInsertBuildingBlock bbName, bbWhere, bookmarkName, info.Pattern, followingBookmark, index, bookmarkExtend

        ' Perform any nested actions in the current ActionAdd object
        FUIActions info.SubActions
    Else

        ' No nodes were returned by the query, so check to see if there is a bookmark that should be
        ' deleted. The bookmark may in turn contain other bookmarks. This provides a mechanism for
        ' deleting corresponding boiler plate text when there is no data for associated bookmarks.

        ' Delete the bookmarked block of text
        bookmarkToDelete = info.DeleteIfNullBookmark
        If LenB(bookmarkToDelete) Then

            ' Replace any numeric placeholders in the bookmark name with their real values
            bookmarkToDelete = g_counters.UpdatePredicates(bookmarkToDelete)

            ' Delete the bookmark and any text and nested bookmarks it may contain
            g_assessmentReport.bookmarks(bookmarkToDelete).Delete
        End If
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' FUIActionAdd

'=======================================================================================================================
' Procedure:    FUIActionSetup
' Purpose:      Performs precursor activities prior to rows (Add actions) being added to tables.
' Notes:        Basically this code makes sure that the Table we need to insert into actually esists. If the Table we
'               need to insert into does not exist then a Building Block is inserted that contains that Table.
'
' On Entry:     info                The ActionSetup object that we need to .
'=======================================================================================================================
Private Sub FUIActionSetup(ByVal info As ActionSetup)
    Const c_proc As String = "modRDAFluentUI.FUIActionSetup"

    Dim bookmarkList()     As String
    Dim bookmarkName       As Variant
    Dim blockBMName        As String
    Dim errorText          As String
    Dim locationBookmarks  As String
    Dim targetArea         As Word.Range
    Dim targetBMName       As String

    On Error GoTo Do_Error

    ' Is the Bookmark that indicates the block we want to insert into present
    blockBMName = g_counters.UpdatePredicates(info.PrimaryBookmark)
    If g_assessmentReport.bookmarks.Exists(blockBMName) Then

        ' Rename all bookmarks starting at the position we will insert the new item at.
        ' This basically changes one of the numeric parts of the bookmark name and increments that numeric part by 1.
        ' By the time this loop finishes we have made a hole in the boomark name sequence which will be used for the
        ' data inserted into the table row/text that forms the Building Block that will be inserted by the 'add' action.
        IncrementallyRenameBookmarks info.RenameBookmarks, mgrP1, CStr(g_counters.Count(1)), _
                                     mgrP2, m_insertIndex, UsedButtonCount
    Else

        ' The block of text we want to insert into does not exist, so we need to insert it using the
        ' location of a boomark that physically preceeds the location of where the block needs to be.
        ' Multiple bookmark names can be defined as not all may exist, the existence of these bookmarks
        ' is predicated on the presence of data. If there is no data for a particular block of text
        ' then that block of text may have been deleted.

        ' Create an array of possible bookmark names, each bookmark is tested in turn, if it does not exist,
        ' the next bookmark in the list is then checked. If none of the bookmarks exist we raise an error.
        locationBookmarks = g_counters.UpdatePredicates(info.SecondaryBookmarks)
        bookmarkList = Split(locationBookmarks, ",")

        ' Stop at the first bookmark that exists
        For Each bookmarkName In bookmarkList

            ' Check whether the bookmark exists
            If g_assessmentReport.bookmarks.Exists(bookmarkName) Then
                targetBMName = bookmarkName
                Exit For
            End If
        Next

        ' Use the bookmark that was found as the location after which the Building Block will be inserted
        If LenB(targetBMName) > 0 Then

            ' Get the bookmarks Range object to that we can work out where to insert the Building Block
            Set targetArea = g_assessmentReport.bookmarks(targetBMName).Range

            ' Insert the specified Building Block into the Assessment Report
            InsertBuildingBlockSimple info.SetupBuildingBlock, targetBMName
        Else
            errorText = Replace$(mgrErrTextNoSpecifiedBookmarkExists, mgrP1, locationBookmarks)
            Err.Raise mgrErrNoNoSpecifiedBookmarkExists, c_proc, errorText
        End If
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' FUIActionSetup

Private Sub AddToXMLAndDocument(ByVal controlNumber As Long)
    Const c_proc As String = "modRDAFluentUI.AddToXMLAndDocument"

    On Error GoTo Do_Error

    ' Add the necessary xml to the DOM Document, this keeps the xml in sync with the Assessment Report
    m_insertIndex = AddToXML(controlNumber)

    ' Now add the text that corresponds to the xml structure we just added
    AddToDocument m_insertIndex

Debug.Print c_proc

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' AddToXMLAndDocument

'=======================================================================================================================
' Procedure:    AddToXML
' Purpose:      Add the required xml to g_xmlDocument (the Assessment Report document).
' Notes:        .
'
' On Entry:     controlNumber       The number of the toggleButton control.
' On Exit:      g_xmlDocument    Updated with the necessary xml.
'=======================================================================================================================
Private Function AddToXML(ByVal controlNumber As Long) As Long
    Const c_proc             As String = "modRDAFluentUI.AddToXML"
    Const c_nonBreakingSpace As Long = 160

    Dim alternativeSibling As MSXML2.IXMLDOMNode
    Dim index              As Long
    Dim newSibling         As MSXML2.IXMLDOMElement
    Dim parentNode         As MSXML2.IXMLDOMNode
    Dim theQuery           As String
    Dim requiredIndex      As Long
    Dim siblingCount       As Long
    Dim siblingIndex       As Long
    Dim siblingNode        As MSXML2.IXMLDOMNode
    Dim siblingNodes       As MSXML2.IXMLDOMNodeList
    Dim siblingSub         As MSXML2.IXMLDOMElement

    On Error GoTo Do_Error

    ' Translate the control number to an index number. We don't care about the control it is the number of the item we want.
    requiredIndex = m_tbReverseMap(controlNumber)

    ' Query to retrieve the parent node we ultimate want to add the xml to
    theQuery = Replace$(g_instructions.UserInterface.QueryParentNodeForAddDelete, mgrP1, m_selectedDropDownValue)
    Set parentNode = g_xmlDocument.SelectSingleNode(theQuery)

    ' #### Bodge together the new node tree we want to add to the parent node ####
    Set newSibling = g_xmlDocument.createNode(NODE_ELEMENT, "findings", vbNullString)
    Set siblingSub = g_xmlDocument.createNode(NODE_ELEMENT, "sectionNumber", vbNullString)
    siblingSub.Text = CStr(requiredIndex)
    newSibling.appendChild siblingSub
    Set siblingSub = g_xmlDocument.createNode(NODE_ELEMENT, "narrative", vbNullString)

    ' Default text to three non-breaking space characters
    siblingSub.Text = Chr$(c_nonBreakingSpace) & Chr$(c_nonBreakingSpace) & Chr$(c_nonBreakingSpace)
    newSibling.appendChild siblingSub

    ' Find out if there are any sibling nodes
    theQuery = Replace$(g_instructions.UserInterface.QueryToggleButtonSiblings, mgrP1, m_selectedDropDownValue)
    Set siblingNodes = g_xmlDocument.SelectNodes(theQuery)

    ' We are trying to keep these nodes with the same tag name contiguous within the DOMDocument. If there are
    ' sibling nodes locate the node we need to insert before, if the new nodes index value is higher than any
    ' existing index number, then it is inserted before the next expected sibling node that has a different name.
    siblingCount = siblingNodes.Length
    If siblingCount > 0 Then

        ' Locate the sibling to insert before, it has to
        For index = 1 To siblingCount

            ' Get the siblings index number from its xml
            siblingIndex = CLng(siblingNodes(index - 1).Text)

            ' Loop until we find a sibling with an index value greater than the index we intend to add
            If requiredIndex < siblingIndex Then

                ' Use the siblings parent as the sibling itself is actually a child node with a numeric value
                Set siblingNode = siblingNodes(index - 1).parentNode

                Exit For
            End If
        Next
    End If

    ' See if a sibling node with the same tag name was found
    If Not siblingNode Is Nothing Then

        ' Insert the new sibling before a sibling with the same tag name
        parentNode.InsertBefore newSibling, siblingNode

        ' Return the position the new node tree was added to the parent
        AddToXML = index
    Else

        ' There are no sibling nodes with the same tag name, so find the next sibling with a different tag name
        theQuery = Replace$(g_instructions.UserInterface.QueryNextSiblingDifferentTag, mgrP1, m_selectedDropDownValue)
        Set alternativeSibling = g_xmlDocument.SelectSingleNode(theQuery)

        ' Insert the new node tree before the alternative sibling node
        parentNode.InsertBefore newSibling, alternativeSibling

        ' Return the position the new node tree was added to the parent
        If index = 0 Then
            AddToXML = 1
        Else
            AddToXML = index
        End If
    End If

    ' Generate the new xml tree (HOW DO WE DO THIS what describes the data and its order (we cant use the XSD).
    ' Maybe restucture the Action xml, and add a new root node, with Actions being a child node. Call the new parent node
    ' 'buildData'???. Add another child node 'ui' with queries and the xml structure of the data we need to add (findings,
    ' findings.sectionNumber, findings.narrative). Also, need to tie it to Add actions to add building block content to
    ' the document.

Do_Exit:
    Exit Function

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Function ' AddToXML

Private Sub DeleteFromXMLAndDocument(ByVal controlNumber As Long)
    Const c_proc As String = "modRDAFluentUI.DeleteFromXMLAndDocument"

    On Error GoTo Do_Error

    m_insertIndex = DeleteFromXML(controlNumber)

    ' The context for what to delete from the Assessment Report is determined by the document structure and the g_counters object
    DeleteFromDocument m_insertIndex

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' DeleteFromXMLAndDocument

Private Function DeleteFromXML(ByVal controlNumber As Long) As Long
    Const c_proc As String = "modRDAFluentUI.DeleteFromXML"

    Dim dataCount     As Long
    Dim dataIndex     As Long
    Dim dataNode      As MSXML2.IXMLDOMNode
    Dim dataNodes     As MSXML2.IXMLDOMNodeList
    Dim index         As Long
    Dim parentNode    As MSXML2.IXMLDOMNode
    Dim theQuery      As String
    Dim requiredIndex As Long

    On Error GoTo Do_Error

    ' Translate the control number to an index number. We don't care about the control its the number of the item we want.
    requiredIndex = m_tbReverseMap(controlNumber)

    ' Query to retrieve the parent node we ultimate want to add the xml to
    theQuery = Replace$(g_instructions.UserInterface.QueryParentNodeForAddDelete, mgrP1, m_selectedDropDownValue)
    Set parentNode = g_xmlDocument.SelectSingleNode(theQuery)

    ' Retrieve all nodes used as the toggleButton data source
    theQuery = Replace$(g_instructions.UserInterface.QueryToggleButtonSiblings, mgrP1, m_selectedDropDownValue)
    Set dataNodes = g_xmlDocument.SelectNodes(theQuery)

    ' Locate the data node we intend to delete
    dataCount = dataNodes.Length
    For index = 1 To dataCount

        ' Get the siblings index number from its xml
        dataIndex = CLng(dataNodes(index - 1).Text)

        ' Find the specified node tree and delete it
        If requiredIndex = dataIndex Then
            Set dataNode = dataNodes(index - 1).parentNode
            DeleteFromXML = index
            Exit For
        End If
    Next

    ' Delete the required xml data node
    If Not dataNode Is Nothing Then
        parentNode.RemoveChild dataNode
    Else
        Err.Raise mgrErrNoUnexpectedCondition, c_proc, mgrErrTextUnexpectedCondition
    End If

Do_Exit:
    Exit Function

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Function ' DeleteFromXML

Private Sub AddToDocument(ByVal insertPosition As Long)
    Const c_proc As String = "modRDAFluentUI.AddToDocument"

    Dim doDocumentProtection As DocumentProtection
    
    On Error GoTo Do_Error

    ' Unprotect the Assessment Report (if it is protected) so that we can add stuff to it.
    ' On termination the instantiated class object will reprotect the document for us.
    Set doDocumentProtection = NewDocumentProtection
    doDocumentProtection.DisableProtection True

    ' Setup the counters object as it is needed to contsruct bookmark names
    SetupCountersBeforeAddOrDelete

    ' The first thing we need to do is iterate the Content Actions to see if there are any setup actions
    ' required before trying to rename bookmarks inpreparation for insert the appropriate Building Blocks
    FUIActions g_instructions.UserInterface.AddContent.actionList

    ' Reprotect the Assessment Report
    Set doDocumentProtection = Nothing

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' AddToDocument

Private Sub DeleteFromDocument(ByVal deletePosition As Long)
    Const c_proc As String = "modRDAFluentUI.DeleteFromDocument"

    Dim bookmarkName         As String
    Dim deletableArea        As Word.Range
    Dim doDocumentProtection As DocumentProtection
    Dim firstRow             As Long
    Dim index                As Long
    Dim lastRow              As Long
    Dim renamableBookmarks   As String
    Dim theTable             As Word.Table

    On Error GoTo Do_Error

    ' Setup the counters object as it is needed to contrsuct bookmark names
    SetupCountersBeforeAddOrDelete

    ' Unprotect the Assessment Report (if it is protected) so that we can add stuff to it.
    ' On termination the instantiated class object will reprotect the document for us.
    Set doDocumentProtection = NewDocumentProtection
    doDocumentProtection.DisableProtection True

    ' If we are deleting the only item of data, then we may need to delete the preface text as well
    If UsedButtonCount = 1 Then

        ' Delete both the preface block and the data
        bookmarkName = g_instructions.UserInterface.DeleteContentUnusedBlockBookmark
    Else

        ' Delete only the bookmarked item of data
        bookmarkName = g_instructions.UserInterface.DeleteContentItemBookmark
    End If

    ' Replace any numeric placeholders with their real values.
    ' This determines which Report/Standard section we are deleting text from.
    bookmarkName = g_counters.UpdatePredicates(bookmarkName)

    ' Delete the bookmarked area which deletes both the text and implicitly the bookmark
    Set deletableArea = g_assessmentReport.bookmarks(bookmarkName).Range

    ' If we are deleting a Row from a Table we can't just use Range.Delete as it does not work. You have to specifically delete
    ' the required Row. But if we are deleting the entire Table (that is wholly contained within the Range) then it does work!
    ' So we have to check to see if we are deleting a Row from the Table (wdWithInTable = True).
    If deletableArea.Information(wdWithInTable) Then

        ' Find out which Row we are deleting
        firstRow = deletableArea.Information(wdStartOfRangeRowNumber)
        lastRow = deletableArea.Information(wdEndOfRangeRowNumber)

        ' Get a reference to the Table object we are going to delete the Row from
        Set theTable = deletableArea.Tables(1)

        ' Delete the Row (there should only be one)
        For index = lastRow To firstRow Step -1
            theTable.Rows(index).Delete
        Next

    Else

        ' The Range object may contain a table, but if it does the entire table is part of the Range and will be deleted
        deletableArea.Delete
    End If

    ' Now that we have deleted a Row from the Table we need to change the numeric parts of the Bookmark names so that the
    ' relationship with the underlying xml remains congruent. To do this we decrease the number of any related Bookmark names
    ' that follow the Table Row that was deleted. The numeric part of Each bookmark name is decreased by one.
    ' This means that the first Row of the Table relates to the first occurrence of the appropriate xml node. The second Row
    ' to the second xml node, the third Row to the third xml node, etc...
    renamableBookmarks = Replace$(g_instructions.UserInterface.DeleteContentRenameBookmarks, mgrP1, CStr(g_counters.Count(1)))
    DecrementallyRenameBookmarks renamableBookmarks, mgrP2, m_insertIndex + 1, UsedButtonCount

Do_Exit:

    ' Reprotect the Assessment Report
    Set doDocumentProtection = Nothing

    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' DeleteFromDocument

'=======================================================================================================================
' Procedure:    FUIInsertBuildingBlock
' Purpose:      .
' Notes:        An alternative way of inserting a row into a table is to split the table, insert the Building Block and
'               then delete the paragraph mark that was added when we split the table.
'
' On Entry:     x                   .
'               y                   .
'=======================================================================================================================
Public Sub FUIInsertBuildingBlock(ByVal bbName As String, _
                                  ByVal bbWhere As rdaWhere, _
                                  ByVal insertBMName As String, _
                                  ByVal secondaryBMName As String, _
                                  ByVal trailingBMName As String, _
                                  ByVal insertPosition As Long, _
                                  ByVal bookmarkExtend As Boolean)
    Const c_proc As String = "modRDAFluentUI.FUIInsertBuildingBlock"

    Dim originalBMEnd     As Long
    Dim originalBMStart   As Long
    Dim secondaryBookmark As Word.Bookmark
    Dim target            As Word.Range
    Dim targetCopy        As Word.Range
    Dim trailingRange     As Word.Range
    Dim useTemplate       As Word.Template
    Dim whereInserted     As Word.Range

    On Error GoTo Do_Error

    ' Add the choosen Building Block to the document
    If LenB(bbName) Then

        ' This is the template that contains all Building Blocks we insert in the Assessment Report
        Set useTemplate = g_assessmentReport.AttachedTemplate

        ' Location to insert the Building Block
        Set target = g_assessmentReport.bookmarks(insertBMName).Range
        originalBMStart = target.Start
        originalBMEnd = target.End

        ' Check to see if we need to insert a Paragraph or NewLine before we insert the Building Block
        Select Case bbWhere
        Case rdaWhereAfterLastParagraph

            ' Start by collapsing the range to the end and then adding either a new paragraph or new line
            target.MoveEndUntil vbCr, 1

            ' Bookmark protection code: This prevents bookmarks in following paragraphs from having their start position extended
            ' to include the Building Block we are inserting. We add a paragraph at the end of the target range and then insert
            ' the Building Block before the added paragraph mark. After we add the Building block we remove the unwanted paragraph.
            If insertPosition > 1 Then
                target.End = target.End - 1
                target.InsertParagraphAfter
            End If

            target.Collapse wdCollapseEnd
            target.Select

        Case rdaWhereAtEndOfRange

            target.Collapse wdCollapseEnd
        End Select

        EventLog "Inserting Building Block: " & bbName

        Set whereInserted = useTemplate.BuildingBlockEntries(bbName).Insert(target, True)

        ' Bookmark protection code: Remove the paragraph mark we added above as it has served its purpose and is no longer required
        If bbWhere = rdaWhereAfterLastParagraph And insertPosition > 1 Then
            Set target = whereInserted
            target.MoveEndWhile vbCr, 1
            target.Start = target.End - 1
            target.Delete
        End If

        ' Recreate the bookmark name as a collapsed range at the end of the inserted block of text.
        ' If Sections are inserted contiguously this bookmark is used for the next insertion point.
        ' If the inserted Section is part of an outer Section, the bookmark will be replaced the
        ' next time another outer Section is inserted as the bookmark will be defined in the outer
        ' Section.
        Set target = g_assessmentReport.bookmarks(insertBMName).Range
        target.End = whereInserted.End

        ' The choice is to either extend the bookmark or to redefine it to what it originally was
        If bookmarkExtend Then
            g_assessmentReport.bookmarks.Add insertBMName, target
        Else

            Set targetCopy = target.Duplicate
            targetCopy.Start = originalBMStart
            targetCopy.End = originalBMEnd
            g_assessmentReport.bookmarks.Add insertBMName, targetCopy
        End If

        ' See if a second bookmark should be create using a name derived from the secondaryBMName
        If LenB(secondaryBMName) Then

            ' Generate the real bookmark name from the pattern
            secondaryBMName = g_counters.UpdatePredicates(secondaryBMName)

            Set secondaryBookmark = g_assessmentReport.bookmarks.Add(secondaryBMName, whereInserted)

            ' If there is a trailing Bookmark (a bookmark following, but contiguous to the bookmark assigned to the Building Block)
            ' it is extended to include the Building Block being inserted - So here we restore this Bookmark
            If trailingBMName <> insertBMName Then
                If g_assessmentReport.bookmarks.Exists(trailingBMName) Then
                    Set trailingRange = g_assessmentReport.bookmarks(trailingBMName).Range
                    trailingRange.Start = secondaryBookmark.Range.End

                    ' Recreate the bookmark so that it does not overlap anything it should not
                    g_assessmentReport.bookmarks.Add trailingBMName, trailingRange
                End If
            End If
        End If
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' FUIInsertBuildingBlock

Private Sub InsertBuildingBlockSimple(ByVal bbName As String, _
                                      ByVal bookmarkName As String)
    Const c_proc As String = "modRDAFluentUI.InsertBuildingBlockSimple"

    Dim target        As Word.Range
    Dim useTemplate   As Word.Template
    Dim whereInserted As Word.Range

    On Error GoTo Do_Error

    If LenB(bbName) > 0 And LenB(bookmarkName) > 0 Then

        ' This is the template that contains all Building Blocks we insert in the Assessment Report
        Set useTemplate = g_assessmentReport.AttachedTemplate

        ' Location to insert the Building Block
        Set target = g_assessmentReport.bookmarks(bookmarkName).Range

        '
        target.Collapse wdCollapseEnd
        target.InsertParagraphAfter
        target.Collapse wdCollapseEnd

        EventLog "Inserting Building Block: " & bbName

        ' Insert the Building Block
        Set whereInserted = useTemplate.BuildingBlockEntries(bbName).Insert(target, True)

        ' Delete the paragraph mark we previously added
        whereInserted.Collapse wdCollapseEnd
        whereInserted.Delete
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' InsertBuildingBlockSimple

'=======================================================================================================================
' Procedure:    DecrementallyRenameBookmarks
' Purpose:      Renames Bookmarks in all rows following the row that was deleted to maintain continuous Bookmark
'               numbering.
' Notes:        This procedure is called when deleting a row from a table.
'
' On Entry:     bookmarkList        A comma delimited list of Bookmark names that need to be renamed.
'               matchPattern        The pattern part ("%1", "%2, ect.) of the Bookmark name to be renumbered.
'               firstNumber         The number Bookmark renaming will start at.
'               lastNumber          The number Bookmark renaming will end at.
'=======================================================================================================================
Private Sub DecrementallyRenameBookmarks(ByVal bookmarkList As String, _
                                         ByVal matchPattern As String, _
                                         ByVal firstNumber As Long, _
                                         ByVal lastNumber As Long)
    Const c_proc As String = "modRDAFluentUI.DecrementallyRenameBookmarks"

    Dim bookmarkName   As Variant
    Dim bookmarks()    As String
    Dim editableBMName As String
    Dim index          As Long
    Dim newBMName      As String          ' New Bookmark name
    Dim oldBMName      As String          ' Old Bookmark name
    Dim target         As Word.Range

    On Error GoTo Do_Error

    ' Split the array of comma delimited bookmark names into an array of bookmark names
    bookmarks() = Split(bookmarkList, ",")

    ' Each bookmark needs all variants of its base name renaming
    For Each bookmarkName In bookmarks

        ' Rename each bookmark in turn, starting with the one with the lowest number working upwards to the highest number
        For index = firstNumber To lastNumber

            ' Create the old and new Bookmark names
            newBMName = Replace$(bookmarkName, matchPattern, CStr(index - 1))
            oldBMName = Replace$(bookmarkName, matchPattern, CStr(index))

            ' Get the Range object of the old Bookmark
            Set target = g_assessmentReport.bookmarks(oldBMName).Range

            ' Create a Bookmark using the new name. This overwrites the bookmark if it already exists.
            g_assessmentReport.bookmarks.Add newBMName, target
        Next

        If LenB(oldBMName) > 0 Then
            editableBMName = oldBMName
        Else

            ' Did not go through the loop, so we need to create our own Bookmark name
            editableBMName = Replace$(bookmarkName, matchPattern, CStr(firstNumber - 1))
        End If

        ' Try removing the Bookmark from the editable Bookmarks Collection object
        If g_editableBookmarks.BookmarkExists(editableBMName) Then
            g_editableBookmarks.BookmarkRemove editableBMName
        End If
    Next

    ' Delete the last (redundant) Bookmark (not the Bookmark contents). If we are deleting the last
    ' item, no bookmarks were renamed. So there is no old Bookmark name to be deleted either.
    If LenB(oldBMName) > 0 Then
        g_assessmentReport.bookmarks(oldBMName).Delete
    End If

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' DecrementallyRenameBookmarks

'=======================================================================================================================
' Procedure:    IncrementallyRenameBookmarks
' Purpose:      Renames Bookmarks in all rows following the row that was added to maintain continuous Bookmark
'               numbering.
' Notes:        This procedure is called when adding a row to a table.
'
' On Entry:     bookmarkList        A comma delimited list of Bookmark names that need to be renamed.
'               matchPattern1       The first pattern part ("%1", "%2, ect.) of the Bookmark name to be renumbered.
'               patternReplacement1 The value to be used to replace the 'matchPattern1' placeholder text.
'               matchPattern2       The second pattern part ("%1", "%2, ect.) of the Bookmark name to be renumbered.
'               firstNumber         The number Bookmark renaming will start at.
'               lastNumber          The number Bookmark renaming will end at.
'=======================================================================================================================
Private Sub IncrementallyRenameBookmarks(ByVal bookmarkList As String, _
                                         ByVal matchPattern1 As String, _
                                         ByVal patternReplacement1 As String, _
                                         ByVal matchPattern2 As String, _
                                         ByVal firstNumber As Long, _
                                         ByVal lastNumber As Long)
    Const c_proc As String = "modRDAFluentUI.IncrementallyRenameBookmarks"

    Dim baseBMName   As String          ' New Bookmark name
    Dim bookmarkName As Variant
    Dim bookmarks()  As String
    Dim index        As Long
    Dim newBMName    As String          ' New Bookmark name
    Dim oldBMName    As String          ' Old Bookmark name
    Dim target       As Word.Range

    On Error GoTo Do_Error

    ' Split the array of comma delimited bookmark names into an array of bookmark names
    bookmarks() = Split(bookmarkList, ",")

    ' Each bookmark needs all variants of its base name renaming
    For Each bookmarkName In bookmarks

        ' Rename each bookmark in turn, starting with the one with the highest number working downwards to the lowest number
        For index = lastNumber To firstNumber Step -1

            ' Create the old and new bookmark names
            baseBMName = Replace$(bookmarkName, matchPattern1, patternReplacement1)
            newBMName = Replace$(baseBMName, matchPattern2, CStr(index + 1))
            oldBMName = Replace$(baseBMName, matchPattern2, CStr(index))

            ' Add a new entry to the editable Bookmark list which is the name of the Bookmark with the greatest index number
            If index = lastNumber Then
                If g_editableBookmarks.IsPatternEditable(bookmarkName) Then
                    g_editableBookmarks.BookmarkAdd newBMName, oldBMName
                End If
            End If

            ' We just leave the Bookmark with the lowest index number as it just gets reused when the row is added to the table

            ' Get the Range object of the old bookmark
            Set target = g_assessmentReport.bookmarks(oldBMName).Range

            ' Create a bookmark using the new name. This overwrites the bookmark if it already exists.
            g_assessmentReport.bookmarks.Add newBMName, target
        Next
    Next

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' IncrementallyRenameBookmarks

Private Function UsedButtonCount() As Long
    Dim index As Long
    Dim ubc   As Long

    ' Determine the number of buttons that have a pressed state. We use this information to infer the maximum number of
    ' items that can exist in an 'add' block.
    For index = LBound(m_stateInfo) To UBound(m_stateInfo)
        If m_stateInfo(index) Then
            ubc = ubc + 1
        End If
    Next

    ' Set the return value
    UsedButtonCount = ubc
End Function ' UsedButtonCount

Private Function LastIndex() As Long
    Dim index As Long

    ' Determine the LastIndex value. The index of the last ToggleButton (not the button number itself, but the xml sibling
    ' identified with that control. In this case we can use this to determine the predicate numbers used to form bookmark names.
    For index = UBound(m_stateInfo) To LBound(m_stateInfo) Step -1
        If m_stateInfo(index) Then
            LastIndex = index
            Exit Function
        End If
    Next
End Function ' LastIndex

Private Sub SetupCountersBeforeAddOrDelete()
    Const c_proc As String = "modRDAFluentUI.SetupCountersBeforeAddOrDelete"

    Dim index As Long

    On Error GoTo Do_Error

    ' Setup the counters object so that it reflects the item we need to insert.
    ' The first counter (%1) is the position of the item selected in the DropDown control.
    For index = LBound(m_primaryItemNames) To UBound(m_primaryItemNames)
        If m_selectedDropDownValue = m_primaryItemNames(index) Then
            g_counters.SetCounter 1, index
            Exit For
        End If
    Next

    ' The second counter is the position of the item we are inserting among other items derived from the same Building Block
    g_counters.SetCounter 2, m_insertIndex

    ' Set the number of active counters
    g_counters.Depth = 2

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' SetupCountersBeforeAddOrDelete

Private Function InsertNumericParameters(ByVal theText As String, _
                                         ParamArray numericValues() As Variant) As String
    Const c_proc As String = "modRDAFluentUI.InsertNumericParameters"

    Dim index     As Long
    Dim lower     As Long
    Dim parameter As String
    Dim subType   As Long
    Dim upper     As Long

    On Error GoTo Do_Error

    ' Validate the ParamArray, make sure it only contains Interger or Long numeric values
    lower = LBound(numericValues)
    upper = UBound(numericValues)

    ' Null array check
    If upper >= lower Then

        ' Now check the type of each parameter
        For index = lower To upper
            subType = VarType(numericValues(index))

            ' Not Interger or Long - then we have a problem Huston
            If Not (subType = vbInteger Or subType = vbLong) Then
                Err.Raise mgrErrNoInvalidProcedureCall, c_proc
            End If
        Next
    Else
        Err.Raise mgrErrNoInvalidProcedureCall, c_proc
    End If

    ' Now replace the parameters placeholder "%1", "%2", %3", etc. with the passed in value (by array position)
    For index = lower To upper
        parameter = "%" & CStr(index + 1)
        theText = Replace$(theText, parameter, numericValues(index))
    Next

    ' Return the string with the parameters replaced with numeric values
    InsertNumericParameters = theText

Do_Exit:
    Exit Function

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Function ' InsertNumericParameters
