Attribute VB_Name = "modRefresh"
'===================================================================================================================================
' Module:       modRefresh
' Purpose:      Recreates the 'rolled-up' parts of a ssar assessemnt report:
' Notes:        The following sections of an ssar assessment report are refreshed:
'               - Heat Maps
'               - Strengths Identified at Review
'               - Recommendations
'               - Overview
'
' Author:       Peter Hewett - Inner Word Limited (innerword@xnet.co.nz)
' Copyright:    Ministry of Social Development (MSD) ©2016 All rights reserved.
' Contact       Inner Word Limited
' details:      134 Kahu Road
'               Paremata
'               Porirua City
'               5024
'               T: +64 4 233 2124
'               M: +64 21 213 5063
'               E: innerword@xnet.co.nz
'
' History:      11/06/16    1.  Created.
'===================================================================================================================================
Option Explicit

'===================================================================================================================================
' Procedure:    SSARFullRefresh
' Purpose:      Performs a full refresh of all necessary sections of a ssar assessment report.
' Date:         11/06/16    Created.
'===================================================================================================================================
Public Sub SSARFullRefresh()
    Const c_proc As String = "modRefresh.SSARFullRefresh"

    Dim selected            As Word.Range
    Dim noScreenUpdating    As ScreenUpdates

    On Error GoTo Do_Error

    EventLog c_proc

    ' Improve code performance and the user experience!
    Set noScreenUpdating = New ScreenUpdates

    ' This is a really nasty kludge to get around a very nasty Word bug.
    ' If the user has text selected in an editable area of the document when this code runs, eventually UpdateAllRefFields
    ' if called. When this procedure runs it deletes the unwanted Editor object added to the Ref Field Result Range.
    ' However, if there is text selected the Editor object for the selected text area is split into two Editor objects,
    ' one either side of the selected text! Given that the Selection object is NOT being used this is very serious.
    ' This kludge gets around it by saving the Selection and collapsing the Selection (which seems to prevent the problem).
    Set selected = Selection.Range
    Selection.Collapse wdCollapseStart

    ' Rebuild the bookmarks before updating the Ref Fields in case the user has pasted data into the
    ' Ref Field source Bookmark, potentially damaging or destroying the Bookmark in the process
    RebuildBookmarksBeforeEdit True

    ' Rebuild all Refreshable document areas (those areas of the assessment report
    ' generated by an Action Add block with refreshable attributes defined
    RefreshAssessmentReport

    ' This is the other part of the above kludge and restores whatever the user had selected
    selected.Select

    ' Restore and repaint the screen
    Set noScreenUpdating = Nothing

    ' Now clean up so the user cannot screw up what we've done by using Undo
    g_assessmentReport.UndoClear

Do_Exit:
    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' SSARFullRefresh

'=======================================================================================================================
' Procedure:    RefreshAssessmentReport
' Purpose:      Regenerates all refreshable areas of the Assessment Report.
' Note 1:       For an area to be considered refreshable its Action Add block must contain the attribute 'refresh' and
'               have a value of True.
' Note 2:       The reason a refresh needs to be performed is that the contents of the refreshable area is dependent on
'               the contents of certain bookmarks. If certain bookmarks contain no data then no preface paragraph and
'               no paragraph(s) contain the data are generated. So these sections display a varying number of paragraphs
'               based on content elsewhere in other editable areas of the Assessment Report.
'=======================================================================================================================
Public Sub RefreshAssessmentReport()
    Const c_proc As String = "modRefresh.RefreshAssessmentReport"

    Dim addAction               As ActionAdd
    Dim bmData                  As String
    Dim deletableArea           As Word.Range
    Dim deletableAreaBM         As String
    Dim doDocumentProtection    As DocumentProtection
    Dim index                   As Long
    Dim refreshActions          As Actions
    Dim refreshableNodes        As MSXML2.IXMLDOMNodeList
    Dim testBM                  As String

    On Error GoTo Do_Error

    EventLog c_proc

    ' Unprotect the Assessment Report (if it is protected) so that we can refresh the necessary areas.
    ' On termination the instantiated class object will reprotect the document for us.
    Set doDocumentProtection = NewDocumentProtection
    doDocumentProtection.DisableProtection True

    ' Initialise the counters collection
    Set g_counters = New Counters

    ' Refresh the assessment report
    Set refreshActions = g_instructions.Refresh
    refreshActions.BuildAssessmentReport

    EventLog c_proc & ": completed"

Do_Exit:

    ' These actions should happen even if there was an error
    Set doDocumentProtection = Nothing

    Exit Sub

Do_Error:
    ErrorReporter c_proc
    Resume Do_Exit
End Sub ' RefreshAssessmentReport

Private Sub DumpEditableAreaInfo()
    Dim bookmarkName  As String
    Dim bmRange         As Word.Range
    Dim dummy         As Word.Range
    Dim editorRange   As Word.Range
    Dim fixBookmark   As Boolean
    Dim index         As Long
    Dim info          As String
    Dim lastEditorStart As Long

    ' Set the starting point for the search for editable ranges to the start of the document
    Set dummy = g_assessmentReport.Content
    dummy.Collapse wdCollapseStart
    dummy.Select

    Do
        lastEditorStart = Selection.Range.Start

        ' Goto the next editable range, when were are at the last editable range this will take us back to the first
        Selection.GoToEditableRange (wdEditorEveryone)
        Set editorRange = Selection.Range

        ' Check to see if we have wrapped around to the first editable range
        If editorRange.Start < lastEditorStart Then Exit Do
        lastEditorStart = editorRange.Start

        index = index + 1

        bookmarkName = g_editableBookmarks.Bookmark(index)
        If g_assessmentReport.bookmarks.Exists(bookmarkName) Then
            Set bmRange = g_assessmentReport.bookmarks(bookmarkName).Range

            ' Dump info
            Debug.Print index & "," & editorRange.Start & "," & editorRange.End & "," & bookmarkName & "," & bmRange.Start & "," & bmRange.End
        Else
            Debug.Print index & "," & editorRange.Start & "," & editorRange.End & "," & bookmarkName & ", ** missing **"
        End If
    Loop
    Exit Sub

        ' Iterate the Editors Dictionary object checking that:
        ' 1. The Bookmark (Dictionary key) actually exists
        ' 2. That the Bookmarks Range matches the Editors Range
        ' If the expected Bookmark does not exist it is created. Likewise if there is
        ' a mismatch in Bookmark Range vs Editor Range the Bookmark will be recreated.
        For index = 1 To g_editableBookmarks.bookmarkCount

            ' Get the key (Bookmark name) and value (an Editor object)
            bookmarkName = g_editableBookmarks.Bookmark(index)


            ' The only way to find Editable ranges is to use the Selection object
            Selection.GoToEditableRange (wdEditorEveryone)
            Set editorRange = Selection.Range

            With g_assessmentReport.bookmarks

                ' Check to see if the bookmark exists
                If .Exists(bookmarkName) Then

                    ' Get the Bookmark Range just the once
                    Set bmRange = .Item(bookmarkName).Range

                    ' Now see if it matches the Editor Range
                    If bmRange.Start <> editorRange.Start Or bmRange.End <> editorRange.End Then
                        info = "Difference detected"
                        fixBookmark = True
                    End If
                Else
                    info = "Undefined bookmark"
                    fixBookmark = True
                End If

                ' See if the Bookmark need recreating or repairing (the same process applies to both)
                If fixBookmark Then

                    ' See if the last character of the Range is a pargraph mark.
                    ' If it is don't include it as part of the editable range.
                    If Right$(editorRange.Text, 1) = vbCr Then

                        ' Delete the current Editor as it includes the paragraph mark
                        editorRange.Editors(1).Delete

                        ' Exclude the final paragraph mark from the Range
                        editorRange.End = editorRange.End - 1

                        ' Recreate the Editor object
                        editorRange.Editors.Add wdEditorEveryone
                    End If

                    Debug.Print info & ", repairing bookmark: " & bookmarkName
                    .Add bookmarkName, editorRange

                    fixBookmark = False
                End If
            End With
        Next

        ' Clear the undo buffer to prevent pottential problems
        g_assessmentReport.UndoClear

End Sub ' DumpEditableAreaInfo
